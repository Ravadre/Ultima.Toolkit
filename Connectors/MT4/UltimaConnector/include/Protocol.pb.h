// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef PROTOBUF_Protocol_2eproto__INCLUDED
#define PROTOBUF_Protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace Ultima {
namespace MT4 {
namespace Packets {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Protocol_2eproto();
void protobuf_AssignDesc_Protocol_2eproto();
void protobuf_ShutdownFile_Protocol_2eproto();

class LoginDTO;
class SymbolRegistrationDTO;
class PriceDTO;
class OpenOrderCommandDTO;
class ModifyOrderCommandDTO;
class CloseOrderCommandDTO;
class CloseOrderByCommandDTO;
class OrderInfoDTO;
class UpdateOrdersDTO;
class CommandResultDTO;
class RequestHistoryDTO;
class HistoryOrderInfoDTO;
class OrdersHistoryDTO;

// ===================================================================

class LoginDTO : public ::google::protobuf::MessageLite {
 public:
  LoginDTO();
  virtual ~LoginDTO();

  LoginDTO(const LoginDTO& from);

  inline LoginDTO& operator=(const LoginDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginDTO* other);

  // implements Message ----------------------------------------------

  LoginDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginDTO& from);
  void MergeFrom(const LoginDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company = 1;
  inline bool has_company() const;
  inline void clear_company();
  static const int kCompanyFieldNumber = 1;
  inline const ::std::string& company() const;
  inline void set_company(const ::std::string& value);
  inline void set_company(const char* value);
  inline void set_company(const char* value, size_t size);
  inline ::std::string* mutable_company();
  inline ::std::string* release_company();
  inline void set_allocated_company(::std::string* company);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.LoginDTO)
 private:
  inline void set_has_company();
  inline void clear_has_company();

  ::std::string* company_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static LoginDTO* default_instance_;
};
// -------------------------------------------------------------------

class SymbolRegistrationDTO : public ::google::protobuf::MessageLite {
 public:
  SymbolRegistrationDTO();
  virtual ~SymbolRegistrationDTO();

  SymbolRegistrationDTO(const SymbolRegistrationDTO& from);

  inline SymbolRegistrationDTO& operator=(const SymbolRegistrationDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const SymbolRegistrationDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SymbolRegistrationDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SymbolRegistrationDTO* other);

  // implements Message ----------------------------------------------

  SymbolRegistrationDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SymbolRegistrationDTO& from);
  void MergeFrom(const SymbolRegistrationDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required bool register = 2;
  inline bool has_register_() const;
  inline void clear_register_();
  static const int kRegisterFieldNumber = 2;
  inline bool register_() const;
  inline void set_register_(bool value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.SymbolRegistrationDTO)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_register_();
  inline void clear_has_register_();

  ::std::string* symbol_;
  bool register__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static SymbolRegistrationDTO* default_instance_;
};
// -------------------------------------------------------------------

class PriceDTO : public ::google::protobuf::MessageLite {
 public:
  PriceDTO();
  virtual ~PriceDTO();

  PriceDTO(const PriceDTO& from);

  inline PriceDTO& operator=(const PriceDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const PriceDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PriceDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PriceDTO* other);

  // implements Message ----------------------------------------------

  PriceDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PriceDTO& from);
  void MergeFrom(const PriceDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required double bid = 2;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 2;
  inline double bid() const;
  inline void set_bid(double value);

  // required double ask = 3;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 3;
  inline double ask() const;
  inline void set_ask(double value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.PriceDTO)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_ask();
  inline void clear_has_ask();

  ::std::string* symbol_;
  double bid_;
  double ask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static PriceDTO* default_instance_;
};
// -------------------------------------------------------------------

class OpenOrderCommandDTO : public ::google::protobuf::MessageLite {
 public:
  OpenOrderCommandDTO();
  virtual ~OpenOrderCommandDTO();

  OpenOrderCommandDTO(const OpenOrderCommandDTO& from);

  inline OpenOrderCommandDTO& operator=(const OpenOrderCommandDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenOrderCommandDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenOrderCommandDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenOrderCommandDTO* other);

  // implements Message ----------------------------------------------

  OpenOrderCommandDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenOrderCommandDTO& from);
  void MergeFrom(const OpenOrderCommandDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // required string symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required int32 tradeCommand = 3;
  inline bool has_tradecommand() const;
  inline void clear_tradecommand();
  static const int kTradeCommandFieldNumber = 3;
  inline ::google::protobuf::int32 tradecommand() const;
  inline void set_tradecommand(::google::protobuf::int32 value);

  // required double volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline double volume() const;
  inline void set_volume(double value);

  // required double openPrice = 5;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 5;
  inline double openprice() const;
  inline void set_openprice(double value);

  // required double stopLoss = 6;
  inline bool has_stoploss() const;
  inline void clear_stoploss();
  static const int kStopLossFieldNumber = 6;
  inline double stoploss() const;
  inline void set_stoploss(double value);

  // required double takeProfit = 7;
  inline bool has_takeprofit() const;
  inline void clear_takeprofit();
  static const int kTakeProfitFieldNumber = 7;
  inline double takeprofit() const;
  inline void set_takeprofit(double value);

  // required int32 slippage = 8;
  inline bool has_slippage() const;
  inline void clear_slippage();
  static const int kSlippageFieldNumber = 8;
  inline ::google::protobuf::int32 slippage() const;
  inline void set_slippage(::google::protobuf::int32 value);

  // optional string comment = 9;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 9;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional int32 magicNumber = 10;
  inline bool has_magicnumber() const;
  inline void clear_magicnumber();
  static const int kMagicNumberFieldNumber = 10;
  inline ::google::protobuf::int32 magicnumber() const;
  inline void set_magicnumber(::google::protobuf::int32 value);

  // required int32 retries = 11;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 11;
  inline ::google::protobuf::int32 retries() const;
  inline void set_retries(::google::protobuf::int32 value);

  // required int32 retrySpanMs = 12;
  inline bool has_retryspanms() const;
  inline void clear_retryspanms();
  static const int kRetrySpanMsFieldNumber = 12;
  inline ::google::protobuf::int32 retryspanms() const;
  inline void set_retryspanms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.OpenOrderCommandDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_tradecommand();
  inline void clear_has_tradecommand();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_stoploss();
  inline void clear_has_stoploss();
  inline void set_has_takeprofit();
  inline void clear_has_takeprofit();
  inline void set_has_slippage();
  inline void clear_has_slippage();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_magicnumber();
  inline void clear_has_magicnumber();
  inline void set_has_retries();
  inline void clear_has_retries();
  inline void set_has_retryspanms();
  inline void clear_has_retryspanms();

  ::std::string* symbol_;
  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 tradecommand_;
  double volume_;
  double openprice_;
  double stoploss_;
  double takeprofit_;
  ::std::string* comment_;
  ::google::protobuf::int32 slippage_;
  ::google::protobuf::int32 magicnumber_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 retryspanms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static OpenOrderCommandDTO* default_instance_;
};
// -------------------------------------------------------------------

class ModifyOrderCommandDTO : public ::google::protobuf::MessageLite {
 public:
  ModifyOrderCommandDTO();
  virtual ~ModifyOrderCommandDTO();

  ModifyOrderCommandDTO(const ModifyOrderCommandDTO& from);

  inline ModifyOrderCommandDTO& operator=(const ModifyOrderCommandDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const ModifyOrderCommandDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ModifyOrderCommandDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ModifyOrderCommandDTO* other);

  // implements Message ----------------------------------------------

  ModifyOrderCommandDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ModifyOrderCommandDTO& from);
  void MergeFrom(const ModifyOrderCommandDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // required int32 order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required double openPrice = 3;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 3;
  inline double openprice() const;
  inline void set_openprice(double value);

  // required double stopLoss = 4;
  inline bool has_stoploss() const;
  inline void clear_stoploss();
  static const int kStopLossFieldNumber = 4;
  inline double stoploss() const;
  inline void set_stoploss(double value);

  // required double takeProfit = 5;
  inline bool has_takeprofit() const;
  inline void clear_takeprofit();
  static const int kTakeProfitFieldNumber = 5;
  inline double takeprofit() const;
  inline void set_takeprofit(double value);

  // required int32 retries = 6;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 6;
  inline ::google::protobuf::int32 retries() const;
  inline void set_retries(::google::protobuf::int32 value);

  // required int32 retrySpanMs = 7;
  inline bool has_retryspanms() const;
  inline void clear_retryspanms();
  static const int kRetrySpanMsFieldNumber = 7;
  inline ::google::protobuf::int32 retryspanms() const;
  inline void set_retryspanms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.ModifyOrderCommandDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_stoploss();
  inline void clear_has_stoploss();
  inline void set_has_takeprofit();
  inline void clear_has_takeprofit();
  inline void set_has_retries();
  inline void clear_has_retries();
  inline void set_has_retryspanms();
  inline void clear_has_retryspanms();

  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 order_;
  double openprice_;
  double stoploss_;
  double takeprofit_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 retryspanms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static ModifyOrderCommandDTO* default_instance_;
};
// -------------------------------------------------------------------

class CloseOrderCommandDTO : public ::google::protobuf::MessageLite {
 public:
  CloseOrderCommandDTO();
  virtual ~CloseOrderCommandDTO();

  CloseOrderCommandDTO(const CloseOrderCommandDTO& from);

  inline CloseOrderCommandDTO& operator=(const CloseOrderCommandDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const CloseOrderCommandDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CloseOrderCommandDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CloseOrderCommandDTO* other);

  // implements Message ----------------------------------------------

  CloseOrderCommandDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CloseOrderCommandDTO& from);
  void MergeFrom(const CloseOrderCommandDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // required int32 order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required int32 retries = 3;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 3;
  inline ::google::protobuf::int32 retries() const;
  inline void set_retries(::google::protobuf::int32 value);

  // required int32 retrySpanMs = 4;
  inline bool has_retryspanms() const;
  inline void clear_retryspanms();
  static const int kRetrySpanMsFieldNumber = 4;
  inline ::google::protobuf::int32 retryspanms() const;
  inline void set_retryspanms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.CloseOrderCommandDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_retries();
  inline void clear_has_retries();
  inline void set_has_retryspanms();
  inline void clear_has_retryspanms();

  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 retryspanms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static CloseOrderCommandDTO* default_instance_;
};
// -------------------------------------------------------------------

class CloseOrderByCommandDTO : public ::google::protobuf::MessageLite {
 public:
  CloseOrderByCommandDTO();
  virtual ~CloseOrderByCommandDTO();

  CloseOrderByCommandDTO(const CloseOrderByCommandDTO& from);

  inline CloseOrderByCommandDTO& operator=(const CloseOrderByCommandDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const CloseOrderByCommandDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CloseOrderByCommandDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CloseOrderByCommandDTO* other);

  // implements Message ----------------------------------------------

  CloseOrderByCommandDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CloseOrderByCommandDTO& from);
  void MergeFrom(const CloseOrderByCommandDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // required int32 order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required int32 orderBy = 3;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 3;
  inline ::google::protobuf::int32 orderby() const;
  inline void set_orderby(::google::protobuf::int32 value);

  // required int32 retries = 4;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 4;
  inline ::google::protobuf::int32 retries() const;
  inline void set_retries(::google::protobuf::int32 value);

  // required int32 retrySpanMs = 5;
  inline bool has_retryspanms() const;
  inline void clear_retryspanms();
  static const int kRetrySpanMsFieldNumber = 5;
  inline ::google::protobuf::int32 retryspanms() const;
  inline void set_retryspanms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.CloseOrderByCommandDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_retries();
  inline void clear_has_retries();
  inline void set_has_retryspanms();
  inline void clear_has_retryspanms();

  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 orderby_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 retryspanms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static CloseOrderByCommandDTO* default_instance_;
};
// -------------------------------------------------------------------

class OrderInfoDTO : public ::google::protobuf::MessageLite {
 public:
  OrderInfoDTO();
  virtual ~OrderInfoDTO();

  OrderInfoDTO(const OrderInfoDTO& from);

  inline OrderInfoDTO& operator=(const OrderInfoDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderInfoDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderInfoDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderInfoDTO* other);

  // implements Message ----------------------------------------------

  OrderInfoDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderInfoDTO& from);
  void MergeFrom(const OrderInfoDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required string symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required int32 tradeCommand = 3;
  inline bool has_tradecommand() const;
  inline void clear_tradecommand();
  static const int kTradeCommandFieldNumber = 3;
  inline ::google::protobuf::int32 tradecommand() const;
  inline void set_tradecommand(::google::protobuf::int32 value);

  // required double volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline double volume() const;
  inline void set_volume(double value);

  // required double openPrice = 5;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 5;
  inline double openprice() const;
  inline void set_openprice(double value);

  // required double stopLoss = 6;
  inline bool has_stoploss() const;
  inline void clear_stoploss();
  static const int kStopLossFieldNumber = 6;
  inline double stoploss() const;
  inline void set_stoploss(double value);

  // required double takeProfit = 7;
  inline bool has_takeprofit() const;
  inline void clear_takeprofit();
  static const int kTakeProfitFieldNumber = 7;
  inline double takeprofit() const;
  inline void set_takeprofit(double value);

  // required double closePrice = 8;
  inline bool has_closeprice() const;
  inline void clear_closeprice();
  static const int kClosePriceFieldNumber = 8;
  inline double closeprice() const;
  inline void set_closeprice(double value);

  // required double profit = 9;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 9;
  inline double profit() const;
  inline void set_profit(double value);

  // required double commission = 10;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 10;
  inline double commission() const;
  inline void set_commission(double value);

  // required double swap = 11;
  inline bool has_swap() const;
  inline void clear_swap();
  static const int kSwapFieldNumber = 11;
  inline double swap() const;
  inline void set_swap(double value);

  // required int32 pointProfit = 12;
  inline bool has_pointprofit() const;
  inline void clear_pointprofit();
  static const int kPointProfitFieldNumber = 12;
  inline ::google::protobuf::int32 pointprofit() const;
  inline void set_pointprofit(::google::protobuf::int32 value);

  // required int32 openTime = 13;
  inline bool has_opentime() const;
  inline void clear_opentime();
  static const int kOpenTimeFieldNumber = 13;
  inline ::google::protobuf::int32 opentime() const;
  inline void set_opentime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.OrderInfoDTO)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_tradecommand();
  inline void clear_has_tradecommand();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_stoploss();
  inline void clear_has_stoploss();
  inline void set_has_takeprofit();
  inline void clear_has_takeprofit();
  inline void set_has_closeprice();
  inline void clear_has_closeprice();
  inline void set_has_profit();
  inline void clear_has_profit();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_swap();
  inline void clear_has_swap();
  inline void set_has_pointprofit();
  inline void clear_has_pointprofit();
  inline void set_has_opentime();
  inline void clear_has_opentime();

  ::std::string* symbol_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 tradecommand_;
  double volume_;
  double openprice_;
  double stoploss_;
  double takeprofit_;
  double closeprice_;
  double profit_;
  double commission_;
  double swap_;
  ::google::protobuf::int32 pointprofit_;
  ::google::protobuf::int32 opentime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static OrderInfoDTO* default_instance_;
};
// -------------------------------------------------------------------

class UpdateOrdersDTO : public ::google::protobuf::MessageLite {
 public:
  UpdateOrdersDTO();
  virtual ~UpdateOrdersDTO();

  UpdateOrdersDTO(const UpdateOrdersDTO& from);

  inline UpdateOrdersDTO& operator=(const UpdateOrdersDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateOrdersDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateOrdersDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateOrdersDTO* other);

  // implements Message ----------------------------------------------

  UpdateOrdersDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateOrdersDTO& from);
  void MergeFrom(const UpdateOrdersDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Ultima.MT4.Packets.OrderInfoDTO orders = 1;
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 1;
  inline const ::Ultima::MT4::Packets::OrderInfoDTO& orders(int index) const;
  inline ::Ultima::MT4::Packets::OrderInfoDTO* mutable_orders(int index);
  inline ::Ultima::MT4::Packets::OrderInfoDTO* add_orders();
  inline const ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::OrderInfoDTO >&
      orders() const;
  inline ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::OrderInfoDTO >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.UpdateOrdersDTO)
 private:

  ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::OrderInfoDTO > orders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static UpdateOrdersDTO* default_instance_;
};
// -------------------------------------------------------------------

class CommandResultDTO : public ::google::protobuf::MessageLite {
 public:
  CommandResultDTO();
  virtual ~CommandResultDTO();

  CommandResultDTO(const CommandResultDTO& from);

  inline CommandResultDTO& operator=(const CommandResultDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const CommandResultDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandResultDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandResultDTO* other);

  // implements Message ----------------------------------------------

  CommandResultDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandResultDTO& from);
  void MergeFrom(const CommandResultDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.CommandResultDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static CommandResultDTO* default_instance_;
};
// -------------------------------------------------------------------

class RequestHistoryDTO : public ::google::protobuf::MessageLite {
 public:
  RequestHistoryDTO();
  virtual ~RequestHistoryDTO();

  RequestHistoryDTO(const RequestHistoryDTO& from);

  inline RequestHistoryDTO& operator=(const RequestHistoryDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestHistoryDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestHistoryDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestHistoryDTO* other);

  // implements Message ----------------------------------------------

  RequestHistoryDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestHistoryDTO& from);
  void MergeFrom(const RequestHistoryDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.RequestHistoryDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::int32 command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static RequestHistoryDTO* default_instance_;
};
// -------------------------------------------------------------------

class HistoryOrderInfoDTO : public ::google::protobuf::MessageLite {
 public:
  HistoryOrderInfoDTO();
  virtual ~HistoryOrderInfoDTO();

  HistoryOrderInfoDTO(const HistoryOrderInfoDTO& from);

  inline HistoryOrderInfoDTO& operator=(const HistoryOrderInfoDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const HistoryOrderInfoDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HistoryOrderInfoDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HistoryOrderInfoDTO* other);

  // implements Message ----------------------------------------------

  HistoryOrderInfoDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HistoryOrderInfoDTO& from);
  void MergeFrom(const HistoryOrderInfoDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // required string symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required int32 tradeCommand = 3;
  inline bool has_tradecommand() const;
  inline void clear_tradecommand();
  static const int kTradeCommandFieldNumber = 3;
  inline ::google::protobuf::int32 tradecommand() const;
  inline void set_tradecommand(::google::protobuf::int32 value);

  // required double volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline double volume() const;
  inline void set_volume(double value);

  // required double openPrice = 5;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 5;
  inline double openprice() const;
  inline void set_openprice(double value);

  // required double stopLoss = 6;
  inline bool has_stoploss() const;
  inline void clear_stoploss();
  static const int kStopLossFieldNumber = 6;
  inline double stoploss() const;
  inline void set_stoploss(double value);

  // required double takeProfit = 7;
  inline bool has_takeprofit() const;
  inline void clear_takeprofit();
  static const int kTakeProfitFieldNumber = 7;
  inline double takeprofit() const;
  inline void set_takeprofit(double value);

  // required double closePrice = 8;
  inline bool has_closeprice() const;
  inline void clear_closeprice();
  static const int kClosePriceFieldNumber = 8;
  inline double closeprice() const;
  inline void set_closeprice(double value);

  // required double profit = 9;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 9;
  inline double profit() const;
  inline void set_profit(double value);

  // required int32 pointProfit = 10;
  inline bool has_pointprofit() const;
  inline void clear_pointprofit();
  static const int kPointProfitFieldNumber = 10;
  inline ::google::protobuf::int32 pointprofit() const;
  inline void set_pointprofit(::google::protobuf::int32 value);

  // required int32 openTime = 11;
  inline bool has_opentime() const;
  inline void clear_opentime();
  static const int kOpenTimeFieldNumber = 11;
  inline ::google::protobuf::int32 opentime() const;
  inline void set_opentime(::google::protobuf::int32 value);

  // required int32 closeTime = 12;
  inline bool has_closetime() const;
  inline void clear_closetime();
  static const int kCloseTimeFieldNumber = 12;
  inline ::google::protobuf::int32 closetime() const;
  inline void set_closetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.HistoryOrderInfoDTO)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_tradecommand();
  inline void clear_has_tradecommand();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_stoploss();
  inline void clear_has_stoploss();
  inline void set_has_takeprofit();
  inline void clear_has_takeprofit();
  inline void set_has_closeprice();
  inline void clear_has_closeprice();
  inline void set_has_profit();
  inline void clear_has_profit();
  inline void set_has_pointprofit();
  inline void clear_has_pointprofit();
  inline void set_has_opentime();
  inline void clear_has_opentime();
  inline void set_has_closetime();
  inline void clear_has_closetime();

  ::std::string* symbol_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 tradecommand_;
  double volume_;
  double openprice_;
  double stoploss_;
  double takeprofit_;
  double closeprice_;
  double profit_;
  ::google::protobuf::int32 pointprofit_;
  ::google::protobuf::int32 opentime_;
  ::google::protobuf::int32 closetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static HistoryOrderInfoDTO* default_instance_;
};
// -------------------------------------------------------------------

class OrdersHistoryDTO : public ::google::protobuf::MessageLite {
 public:
  OrdersHistoryDTO();
  virtual ~OrdersHistoryDTO();

  OrdersHistoryDTO(const OrdersHistoryDTO& from);

  inline OrdersHistoryDTO& operator=(const OrdersHistoryDTO& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrdersHistoryDTO& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrdersHistoryDTO* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrdersHistoryDTO* other);

  // implements Message ----------------------------------------------

  OrdersHistoryDTO* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrdersHistoryDTO& from);
  void MergeFrom(const OrdersHistoryDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::int32 command() const;
  inline void set_command(::google::protobuf::int32 value);

  // repeated .Ultima.MT4.Packets.HistoryOrderInfoDTO orders = 2;
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 2;
  inline const ::Ultima::MT4::Packets::HistoryOrderInfoDTO& orders(int index) const;
  inline ::Ultima::MT4::Packets::HistoryOrderInfoDTO* mutable_orders(int index);
  inline ::Ultima::MT4::Packets::HistoryOrderInfoDTO* add_orders();
  inline const ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::HistoryOrderInfoDTO >&
      orders() const;
  inline ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::HistoryOrderInfoDTO >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:Ultima.MT4.Packets.OrdersHistoryDTO)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::HistoryOrderInfoDTO > orders_;
  ::google::protobuf::int32 command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Protocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Protocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_Protocol_2eproto();
  friend void protobuf_ShutdownFile_Protocol_2eproto();

  void InitAsDefaultInstance();
  static OrdersHistoryDTO* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginDTO

// required string company = 1;
inline bool LoginDTO::has_company() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginDTO::set_has_company() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginDTO::clear_has_company() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginDTO::clear_company() {
  if (company_ != &::google::protobuf::internal::kEmptyString) {
    company_->clear();
  }
  clear_has_company();
}
inline const ::std::string& LoginDTO::company() const {
  return *company_;
}
inline void LoginDTO::set_company(const ::std::string& value) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::kEmptyString) {
    company_ = new ::std::string;
  }
  company_->assign(value);
}
inline void LoginDTO::set_company(const char* value) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::kEmptyString) {
    company_ = new ::std::string;
  }
  company_->assign(value);
}
inline void LoginDTO::set_company(const char* value, size_t size) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::kEmptyString) {
    company_ = new ::std::string;
  }
  company_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDTO::mutable_company() {
  set_has_company();
  if (company_ == &::google::protobuf::internal::kEmptyString) {
    company_ = new ::std::string;
  }
  return company_;
}
inline ::std::string* LoginDTO::release_company() {
  clear_has_company();
  if (company_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = company_;
    company_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDTO::set_allocated_company(::std::string* company) {
  if (company_ != &::google::protobuf::internal::kEmptyString) {
    delete company_;
  }
  if (company) {
    set_has_company();
    company_ = company;
  } else {
    clear_has_company();
    company_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SymbolRegistrationDTO

// required string symbol = 1;
inline bool SymbolRegistrationDTO::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolRegistrationDTO::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolRegistrationDTO::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolRegistrationDTO::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SymbolRegistrationDTO::symbol() const {
  return *symbol_;
}
inline void SymbolRegistrationDTO::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void SymbolRegistrationDTO::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void SymbolRegistrationDTO::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolRegistrationDTO::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* SymbolRegistrationDTO::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SymbolRegistrationDTO::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool register = 2;
inline bool SymbolRegistrationDTO::has_register_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolRegistrationDTO::set_has_register_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolRegistrationDTO::clear_has_register_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolRegistrationDTO::clear_register_() {
  register__ = false;
  clear_has_register_();
}
inline bool SymbolRegistrationDTO::register_() const {
  return register__;
}
inline void SymbolRegistrationDTO::set_register_(bool value) {
  set_has_register_();
  register__ = value;
}

// -------------------------------------------------------------------

// PriceDTO

// required string symbol = 1;
inline bool PriceDTO::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceDTO::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceDTO::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceDTO::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& PriceDTO::symbol() const {
  return *symbol_;
}
inline void PriceDTO::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void PriceDTO::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void PriceDTO::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceDTO::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* PriceDTO::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceDTO::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double bid = 2;
inline bool PriceDTO::has_bid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceDTO::set_has_bid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceDTO::clear_has_bid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceDTO::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline double PriceDTO::bid() const {
  return bid_;
}
inline void PriceDTO::set_bid(double value) {
  set_has_bid();
  bid_ = value;
}

// required double ask = 3;
inline bool PriceDTO::has_ask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceDTO::set_has_ask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceDTO::clear_has_ask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceDTO::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline double PriceDTO::ask() const {
  return ask_;
}
inline void PriceDTO::set_ask(double value) {
  set_has_ask();
  ask_ = value;
}

// -------------------------------------------------------------------

// OpenOrderCommandDTO

// required int32 command = 1;
inline bool OpenOrderCommandDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenOrderCommandDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenOrderCommandDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenOrderCommandDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::command() const {
  return command_;
}
inline void OpenOrderCommandDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// required string symbol = 2;
inline bool OpenOrderCommandDTO::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenOrderCommandDTO::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenOrderCommandDTO::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenOrderCommandDTO::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& OpenOrderCommandDTO::symbol() const {
  return *symbol_;
}
inline void OpenOrderCommandDTO::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OpenOrderCommandDTO::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OpenOrderCommandDTO::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenOrderCommandDTO::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* OpenOrderCommandDTO::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenOrderCommandDTO::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 tradeCommand = 3;
inline bool OpenOrderCommandDTO::has_tradecommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenOrderCommandDTO::set_has_tradecommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenOrderCommandDTO::clear_has_tradecommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenOrderCommandDTO::clear_tradecommand() {
  tradecommand_ = 0;
  clear_has_tradecommand();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::tradecommand() const {
  return tradecommand_;
}
inline void OpenOrderCommandDTO::set_tradecommand(::google::protobuf::int32 value) {
  set_has_tradecommand();
  tradecommand_ = value;
}

// required double volume = 4;
inline bool OpenOrderCommandDTO::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenOrderCommandDTO::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenOrderCommandDTO::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenOrderCommandDTO::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OpenOrderCommandDTO::volume() const {
  return volume_;
}
inline void OpenOrderCommandDTO::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// required double openPrice = 5;
inline bool OpenOrderCommandDTO::has_openprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenOrderCommandDTO::set_has_openprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenOrderCommandDTO::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenOrderCommandDTO::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double OpenOrderCommandDTO::openprice() const {
  return openprice_;
}
inline void OpenOrderCommandDTO::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
}

// required double stopLoss = 6;
inline bool OpenOrderCommandDTO::has_stoploss() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OpenOrderCommandDTO::set_has_stoploss() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OpenOrderCommandDTO::clear_has_stoploss() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OpenOrderCommandDTO::clear_stoploss() {
  stoploss_ = 0;
  clear_has_stoploss();
}
inline double OpenOrderCommandDTO::stoploss() const {
  return stoploss_;
}
inline void OpenOrderCommandDTO::set_stoploss(double value) {
  set_has_stoploss();
  stoploss_ = value;
}

// required double takeProfit = 7;
inline bool OpenOrderCommandDTO::has_takeprofit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OpenOrderCommandDTO::set_has_takeprofit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OpenOrderCommandDTO::clear_has_takeprofit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OpenOrderCommandDTO::clear_takeprofit() {
  takeprofit_ = 0;
  clear_has_takeprofit();
}
inline double OpenOrderCommandDTO::takeprofit() const {
  return takeprofit_;
}
inline void OpenOrderCommandDTO::set_takeprofit(double value) {
  set_has_takeprofit();
  takeprofit_ = value;
}

// required int32 slippage = 8;
inline bool OpenOrderCommandDTO::has_slippage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OpenOrderCommandDTO::set_has_slippage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OpenOrderCommandDTO::clear_has_slippage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OpenOrderCommandDTO::clear_slippage() {
  slippage_ = 0;
  clear_has_slippage();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::slippage() const {
  return slippage_;
}
inline void OpenOrderCommandDTO::set_slippage(::google::protobuf::int32 value) {
  set_has_slippage();
  slippage_ = value;
}

// optional string comment = 9;
inline bool OpenOrderCommandDTO::has_comment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OpenOrderCommandDTO::set_has_comment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OpenOrderCommandDTO::clear_has_comment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OpenOrderCommandDTO::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& OpenOrderCommandDTO::comment() const {
  return *comment_;
}
inline void OpenOrderCommandDTO::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void OpenOrderCommandDTO::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void OpenOrderCommandDTO::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenOrderCommandDTO::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* OpenOrderCommandDTO::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenOrderCommandDTO::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 magicNumber = 10;
inline bool OpenOrderCommandDTO::has_magicnumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OpenOrderCommandDTO::set_has_magicnumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OpenOrderCommandDTO::clear_has_magicnumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OpenOrderCommandDTO::clear_magicnumber() {
  magicnumber_ = 0;
  clear_has_magicnumber();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::magicnumber() const {
  return magicnumber_;
}
inline void OpenOrderCommandDTO::set_magicnumber(::google::protobuf::int32 value) {
  set_has_magicnumber();
  magicnumber_ = value;
}

// required int32 retries = 11;
inline bool OpenOrderCommandDTO::has_retries() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OpenOrderCommandDTO::set_has_retries() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OpenOrderCommandDTO::clear_has_retries() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OpenOrderCommandDTO::clear_retries() {
  retries_ = 0;
  clear_has_retries();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::retries() const {
  return retries_;
}
inline void OpenOrderCommandDTO::set_retries(::google::protobuf::int32 value) {
  set_has_retries();
  retries_ = value;
}

// required int32 retrySpanMs = 12;
inline bool OpenOrderCommandDTO::has_retryspanms() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OpenOrderCommandDTO::set_has_retryspanms() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OpenOrderCommandDTO::clear_has_retryspanms() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OpenOrderCommandDTO::clear_retryspanms() {
  retryspanms_ = 0;
  clear_has_retryspanms();
}
inline ::google::protobuf::int32 OpenOrderCommandDTO::retryspanms() const {
  return retryspanms_;
}
inline void OpenOrderCommandDTO::set_retryspanms(::google::protobuf::int32 value) {
  set_has_retryspanms();
  retryspanms_ = value;
}

// -------------------------------------------------------------------

// ModifyOrderCommandDTO

// required int32 command = 1;
inline bool ModifyOrderCommandDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyOrderCommandDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyOrderCommandDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 ModifyOrderCommandDTO::command() const {
  return command_;
}
inline void ModifyOrderCommandDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// required int32 order = 2;
inline bool ModifyOrderCommandDTO::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyOrderCommandDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyOrderCommandDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 ModifyOrderCommandDTO::order() const {
  return order_;
}
inline void ModifyOrderCommandDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// required double openPrice = 3;
inline bool ModifyOrderCommandDTO::has_openprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_openprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyOrderCommandDTO::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyOrderCommandDTO::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double ModifyOrderCommandDTO::openprice() const {
  return openprice_;
}
inline void ModifyOrderCommandDTO::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
}

// required double stopLoss = 4;
inline bool ModifyOrderCommandDTO::has_stoploss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_stoploss() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyOrderCommandDTO::clear_has_stoploss() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyOrderCommandDTO::clear_stoploss() {
  stoploss_ = 0;
  clear_has_stoploss();
}
inline double ModifyOrderCommandDTO::stoploss() const {
  return stoploss_;
}
inline void ModifyOrderCommandDTO::set_stoploss(double value) {
  set_has_stoploss();
  stoploss_ = value;
}

// required double takeProfit = 5;
inline bool ModifyOrderCommandDTO::has_takeprofit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_takeprofit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyOrderCommandDTO::clear_has_takeprofit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyOrderCommandDTO::clear_takeprofit() {
  takeprofit_ = 0;
  clear_has_takeprofit();
}
inline double ModifyOrderCommandDTO::takeprofit() const {
  return takeprofit_;
}
inline void ModifyOrderCommandDTO::set_takeprofit(double value) {
  set_has_takeprofit();
  takeprofit_ = value;
}

// required int32 retries = 6;
inline bool ModifyOrderCommandDTO::has_retries() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_retries() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModifyOrderCommandDTO::clear_has_retries() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModifyOrderCommandDTO::clear_retries() {
  retries_ = 0;
  clear_has_retries();
}
inline ::google::protobuf::int32 ModifyOrderCommandDTO::retries() const {
  return retries_;
}
inline void ModifyOrderCommandDTO::set_retries(::google::protobuf::int32 value) {
  set_has_retries();
  retries_ = value;
}

// required int32 retrySpanMs = 7;
inline bool ModifyOrderCommandDTO::has_retryspanms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModifyOrderCommandDTO::set_has_retryspanms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModifyOrderCommandDTO::clear_has_retryspanms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModifyOrderCommandDTO::clear_retryspanms() {
  retryspanms_ = 0;
  clear_has_retryspanms();
}
inline ::google::protobuf::int32 ModifyOrderCommandDTO::retryspanms() const {
  return retryspanms_;
}
inline void ModifyOrderCommandDTO::set_retryspanms(::google::protobuf::int32 value) {
  set_has_retryspanms();
  retryspanms_ = value;
}

// -------------------------------------------------------------------

// CloseOrderCommandDTO

// required int32 command = 1;
inline bool CloseOrderCommandDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseOrderCommandDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseOrderCommandDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseOrderCommandDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 CloseOrderCommandDTO::command() const {
  return command_;
}
inline void CloseOrderCommandDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// required int32 order = 2;
inline bool CloseOrderCommandDTO::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseOrderCommandDTO::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseOrderCommandDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseOrderCommandDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 CloseOrderCommandDTO::order() const {
  return order_;
}
inline void CloseOrderCommandDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// required int32 retries = 3;
inline bool CloseOrderCommandDTO::has_retries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseOrderCommandDTO::set_has_retries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseOrderCommandDTO::clear_has_retries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseOrderCommandDTO::clear_retries() {
  retries_ = 0;
  clear_has_retries();
}
inline ::google::protobuf::int32 CloseOrderCommandDTO::retries() const {
  return retries_;
}
inline void CloseOrderCommandDTO::set_retries(::google::protobuf::int32 value) {
  set_has_retries();
  retries_ = value;
}

// required int32 retrySpanMs = 4;
inline bool CloseOrderCommandDTO::has_retryspanms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CloseOrderCommandDTO::set_has_retryspanms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CloseOrderCommandDTO::clear_has_retryspanms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CloseOrderCommandDTO::clear_retryspanms() {
  retryspanms_ = 0;
  clear_has_retryspanms();
}
inline ::google::protobuf::int32 CloseOrderCommandDTO::retryspanms() const {
  return retryspanms_;
}
inline void CloseOrderCommandDTO::set_retryspanms(::google::protobuf::int32 value) {
  set_has_retryspanms();
  retryspanms_ = value;
}

// -------------------------------------------------------------------

// CloseOrderByCommandDTO

// required int32 command = 1;
inline bool CloseOrderByCommandDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseOrderByCommandDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseOrderByCommandDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseOrderByCommandDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 CloseOrderByCommandDTO::command() const {
  return command_;
}
inline void CloseOrderByCommandDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// required int32 order = 2;
inline bool CloseOrderByCommandDTO::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseOrderByCommandDTO::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseOrderByCommandDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseOrderByCommandDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 CloseOrderByCommandDTO::order() const {
  return order_;
}
inline void CloseOrderByCommandDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// required int32 orderBy = 3;
inline bool CloseOrderByCommandDTO::has_orderby() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseOrderByCommandDTO::set_has_orderby() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseOrderByCommandDTO::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseOrderByCommandDTO::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::google::protobuf::int32 CloseOrderByCommandDTO::orderby() const {
  return orderby_;
}
inline void CloseOrderByCommandDTO::set_orderby(::google::protobuf::int32 value) {
  set_has_orderby();
  orderby_ = value;
}

// required int32 retries = 4;
inline bool CloseOrderByCommandDTO::has_retries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CloseOrderByCommandDTO::set_has_retries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CloseOrderByCommandDTO::clear_has_retries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CloseOrderByCommandDTO::clear_retries() {
  retries_ = 0;
  clear_has_retries();
}
inline ::google::protobuf::int32 CloseOrderByCommandDTO::retries() const {
  return retries_;
}
inline void CloseOrderByCommandDTO::set_retries(::google::protobuf::int32 value) {
  set_has_retries();
  retries_ = value;
}

// required int32 retrySpanMs = 5;
inline bool CloseOrderByCommandDTO::has_retryspanms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CloseOrderByCommandDTO::set_has_retryspanms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CloseOrderByCommandDTO::clear_has_retryspanms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CloseOrderByCommandDTO::clear_retryspanms() {
  retryspanms_ = 0;
  clear_has_retryspanms();
}
inline ::google::protobuf::int32 CloseOrderByCommandDTO::retryspanms() const {
  return retryspanms_;
}
inline void CloseOrderByCommandDTO::set_retryspanms(::google::protobuf::int32 value) {
  set_has_retryspanms();
  retryspanms_ = value;
}

// -------------------------------------------------------------------

// OrderInfoDTO

// required int32 order = 1;
inline bool OrderInfoDTO::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfoDTO::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfoDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfoDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 OrderInfoDTO::order() const {
  return order_;
}
inline void OrderInfoDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// required string symbol = 2;
inline bool OrderInfoDTO::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfoDTO::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfoDTO::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfoDTO::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& OrderInfoDTO::symbol() const {
  return *symbol_;
}
inline void OrderInfoDTO::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OrderInfoDTO::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OrderInfoDTO::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoDTO::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* OrderInfoDTO::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderInfoDTO::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 tradeCommand = 3;
inline bool OrderInfoDTO::has_tradecommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfoDTO::set_has_tradecommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfoDTO::clear_has_tradecommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfoDTO::clear_tradecommand() {
  tradecommand_ = 0;
  clear_has_tradecommand();
}
inline ::google::protobuf::int32 OrderInfoDTO::tradecommand() const {
  return tradecommand_;
}
inline void OrderInfoDTO::set_tradecommand(::google::protobuf::int32 value) {
  set_has_tradecommand();
  tradecommand_ = value;
}

// required double volume = 4;
inline bool OrderInfoDTO::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderInfoDTO::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderInfoDTO::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderInfoDTO::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OrderInfoDTO::volume() const {
  return volume_;
}
inline void OrderInfoDTO::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// required double openPrice = 5;
inline bool OrderInfoDTO::has_openprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderInfoDTO::set_has_openprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderInfoDTO::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderInfoDTO::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double OrderInfoDTO::openprice() const {
  return openprice_;
}
inline void OrderInfoDTO::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
}

// required double stopLoss = 6;
inline bool OrderInfoDTO::has_stoploss() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderInfoDTO::set_has_stoploss() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderInfoDTO::clear_has_stoploss() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderInfoDTO::clear_stoploss() {
  stoploss_ = 0;
  clear_has_stoploss();
}
inline double OrderInfoDTO::stoploss() const {
  return stoploss_;
}
inline void OrderInfoDTO::set_stoploss(double value) {
  set_has_stoploss();
  stoploss_ = value;
}

// required double takeProfit = 7;
inline bool OrderInfoDTO::has_takeprofit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderInfoDTO::set_has_takeprofit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderInfoDTO::clear_has_takeprofit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderInfoDTO::clear_takeprofit() {
  takeprofit_ = 0;
  clear_has_takeprofit();
}
inline double OrderInfoDTO::takeprofit() const {
  return takeprofit_;
}
inline void OrderInfoDTO::set_takeprofit(double value) {
  set_has_takeprofit();
  takeprofit_ = value;
}

// required double closePrice = 8;
inline bool OrderInfoDTO::has_closeprice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderInfoDTO::set_has_closeprice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderInfoDTO::clear_has_closeprice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderInfoDTO::clear_closeprice() {
  closeprice_ = 0;
  clear_has_closeprice();
}
inline double OrderInfoDTO::closeprice() const {
  return closeprice_;
}
inline void OrderInfoDTO::set_closeprice(double value) {
  set_has_closeprice();
  closeprice_ = value;
}

// required double profit = 9;
inline bool OrderInfoDTO::has_profit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderInfoDTO::set_has_profit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderInfoDTO::clear_has_profit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderInfoDTO::clear_profit() {
  profit_ = 0;
  clear_has_profit();
}
inline double OrderInfoDTO::profit() const {
  return profit_;
}
inline void OrderInfoDTO::set_profit(double value) {
  set_has_profit();
  profit_ = value;
}

// required double commission = 10;
inline bool OrderInfoDTO::has_commission() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderInfoDTO::set_has_commission() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderInfoDTO::clear_has_commission() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderInfoDTO::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double OrderInfoDTO::commission() const {
  return commission_;
}
inline void OrderInfoDTO::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double swap = 11;
inline bool OrderInfoDTO::has_swap() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderInfoDTO::set_has_swap() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderInfoDTO::clear_has_swap() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderInfoDTO::clear_swap() {
  swap_ = 0;
  clear_has_swap();
}
inline double OrderInfoDTO::swap() const {
  return swap_;
}
inline void OrderInfoDTO::set_swap(double value) {
  set_has_swap();
  swap_ = value;
}

// required int32 pointProfit = 12;
inline bool OrderInfoDTO::has_pointprofit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderInfoDTO::set_has_pointprofit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderInfoDTO::clear_has_pointprofit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderInfoDTO::clear_pointprofit() {
  pointprofit_ = 0;
  clear_has_pointprofit();
}
inline ::google::protobuf::int32 OrderInfoDTO::pointprofit() const {
  return pointprofit_;
}
inline void OrderInfoDTO::set_pointprofit(::google::protobuf::int32 value) {
  set_has_pointprofit();
  pointprofit_ = value;
}

// required int32 openTime = 13;
inline bool OrderInfoDTO::has_opentime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderInfoDTO::set_has_opentime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderInfoDTO::clear_has_opentime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderInfoDTO::clear_opentime() {
  opentime_ = 0;
  clear_has_opentime();
}
inline ::google::protobuf::int32 OrderInfoDTO::opentime() const {
  return opentime_;
}
inline void OrderInfoDTO::set_opentime(::google::protobuf::int32 value) {
  set_has_opentime();
  opentime_ = value;
}

// -------------------------------------------------------------------

// UpdateOrdersDTO

// repeated .Ultima.MT4.Packets.OrderInfoDTO orders = 1;
inline int UpdateOrdersDTO::orders_size() const {
  return orders_.size();
}
inline void UpdateOrdersDTO::clear_orders() {
  orders_.Clear();
}
inline const ::Ultima::MT4::Packets::OrderInfoDTO& UpdateOrdersDTO::orders(int index) const {
  return orders_.Get(index);
}
inline ::Ultima::MT4::Packets::OrderInfoDTO* UpdateOrdersDTO::mutable_orders(int index) {
  return orders_.Mutable(index);
}
inline ::Ultima::MT4::Packets::OrderInfoDTO* UpdateOrdersDTO::add_orders() {
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::OrderInfoDTO >&
UpdateOrdersDTO::orders() const {
  return orders_;
}
inline ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::OrderInfoDTO >*
UpdateOrdersDTO::mutable_orders() {
  return &orders_;
}

// -------------------------------------------------------------------

// CommandResultDTO

// required int32 command = 1;
inline bool CommandResultDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResultDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResultDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResultDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 CommandResultDTO::command() const {
  return command_;
}
inline void CommandResultDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// required int32 result = 2;
inline bool CommandResultDTO::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResultDTO::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResultDTO::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResultDTO::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CommandResultDTO::result() const {
  return result_;
}
inline void CommandResultDTO::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 order = 3;
inline bool CommandResultDTO::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResultDTO::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResultDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResultDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 CommandResultDTO::order() const {
  return order_;
}
inline void CommandResultDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// RequestHistoryDTO

// required int32 command = 1;
inline bool RequestHistoryDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHistoryDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHistoryDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHistoryDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 RequestHistoryDTO::command() const {
  return command_;
}
inline void RequestHistoryDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// -------------------------------------------------------------------

// HistoryOrderInfoDTO

// required int32 order = 1;
inline bool HistoryOrderInfoDTO::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryOrderInfoDTO::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryOrderInfoDTO::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 HistoryOrderInfoDTO::order() const {
  return order_;
}
inline void HistoryOrderInfoDTO::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// required string symbol = 2;
inline bool HistoryOrderInfoDTO::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryOrderInfoDTO::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryOrderInfoDTO::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& HistoryOrderInfoDTO::symbol() const {
  return *symbol_;
}
inline void HistoryOrderInfoDTO::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void HistoryOrderInfoDTO::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void HistoryOrderInfoDTO::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryOrderInfoDTO::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* HistoryOrderInfoDTO::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryOrderInfoDTO::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 tradeCommand = 3;
inline bool HistoryOrderInfoDTO::has_tradecommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_tradecommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryOrderInfoDTO::clear_has_tradecommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryOrderInfoDTO::clear_tradecommand() {
  tradecommand_ = 0;
  clear_has_tradecommand();
}
inline ::google::protobuf::int32 HistoryOrderInfoDTO::tradecommand() const {
  return tradecommand_;
}
inline void HistoryOrderInfoDTO::set_tradecommand(::google::protobuf::int32 value) {
  set_has_tradecommand();
  tradecommand_ = value;
}

// required double volume = 4;
inline bool HistoryOrderInfoDTO::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryOrderInfoDTO::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryOrderInfoDTO::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double HistoryOrderInfoDTO::volume() const {
  return volume_;
}
inline void HistoryOrderInfoDTO::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// required double openPrice = 5;
inline bool HistoryOrderInfoDTO::has_openprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_openprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryOrderInfoDTO::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryOrderInfoDTO::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double HistoryOrderInfoDTO::openprice() const {
  return openprice_;
}
inline void HistoryOrderInfoDTO::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
}

// required double stopLoss = 6;
inline bool HistoryOrderInfoDTO::has_stoploss() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_stoploss() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoryOrderInfoDTO::clear_has_stoploss() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoryOrderInfoDTO::clear_stoploss() {
  stoploss_ = 0;
  clear_has_stoploss();
}
inline double HistoryOrderInfoDTO::stoploss() const {
  return stoploss_;
}
inline void HistoryOrderInfoDTO::set_stoploss(double value) {
  set_has_stoploss();
  stoploss_ = value;
}

// required double takeProfit = 7;
inline bool HistoryOrderInfoDTO::has_takeprofit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_takeprofit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoryOrderInfoDTO::clear_has_takeprofit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoryOrderInfoDTO::clear_takeprofit() {
  takeprofit_ = 0;
  clear_has_takeprofit();
}
inline double HistoryOrderInfoDTO::takeprofit() const {
  return takeprofit_;
}
inline void HistoryOrderInfoDTO::set_takeprofit(double value) {
  set_has_takeprofit();
  takeprofit_ = value;
}

// required double closePrice = 8;
inline bool HistoryOrderInfoDTO::has_closeprice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_closeprice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoryOrderInfoDTO::clear_has_closeprice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoryOrderInfoDTO::clear_closeprice() {
  closeprice_ = 0;
  clear_has_closeprice();
}
inline double HistoryOrderInfoDTO::closeprice() const {
  return closeprice_;
}
inline void HistoryOrderInfoDTO::set_closeprice(double value) {
  set_has_closeprice();
  closeprice_ = value;
}

// required double profit = 9;
inline bool HistoryOrderInfoDTO::has_profit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_profit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoryOrderInfoDTO::clear_has_profit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoryOrderInfoDTO::clear_profit() {
  profit_ = 0;
  clear_has_profit();
}
inline double HistoryOrderInfoDTO::profit() const {
  return profit_;
}
inline void HistoryOrderInfoDTO::set_profit(double value) {
  set_has_profit();
  profit_ = value;
}

// required int32 pointProfit = 10;
inline bool HistoryOrderInfoDTO::has_pointprofit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_pointprofit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoryOrderInfoDTO::clear_has_pointprofit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoryOrderInfoDTO::clear_pointprofit() {
  pointprofit_ = 0;
  clear_has_pointprofit();
}
inline ::google::protobuf::int32 HistoryOrderInfoDTO::pointprofit() const {
  return pointprofit_;
}
inline void HistoryOrderInfoDTO::set_pointprofit(::google::protobuf::int32 value) {
  set_has_pointprofit();
  pointprofit_ = value;
}

// required int32 openTime = 11;
inline bool HistoryOrderInfoDTO::has_opentime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_opentime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoryOrderInfoDTO::clear_has_opentime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoryOrderInfoDTO::clear_opentime() {
  opentime_ = 0;
  clear_has_opentime();
}
inline ::google::protobuf::int32 HistoryOrderInfoDTO::opentime() const {
  return opentime_;
}
inline void HistoryOrderInfoDTO::set_opentime(::google::protobuf::int32 value) {
  set_has_opentime();
  opentime_ = value;
}

// required int32 closeTime = 12;
inline bool HistoryOrderInfoDTO::has_closetime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HistoryOrderInfoDTO::set_has_closetime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HistoryOrderInfoDTO::clear_has_closetime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HistoryOrderInfoDTO::clear_closetime() {
  closetime_ = 0;
  clear_has_closetime();
}
inline ::google::protobuf::int32 HistoryOrderInfoDTO::closetime() const {
  return closetime_;
}
inline void HistoryOrderInfoDTO::set_closetime(::google::protobuf::int32 value) {
  set_has_closetime();
  closetime_ = value;
}

// -------------------------------------------------------------------

// OrdersHistoryDTO

// required int32 command = 1;
inline bool OrdersHistoryDTO::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrdersHistoryDTO::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrdersHistoryDTO::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrdersHistoryDTO::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 OrdersHistoryDTO::command() const {
  return command_;
}
inline void OrdersHistoryDTO::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
}

// repeated .Ultima.MT4.Packets.HistoryOrderInfoDTO orders = 2;
inline int OrdersHistoryDTO::orders_size() const {
  return orders_.size();
}
inline void OrdersHistoryDTO::clear_orders() {
  orders_.Clear();
}
inline const ::Ultima::MT4::Packets::HistoryOrderInfoDTO& OrdersHistoryDTO::orders(int index) const {
  return orders_.Get(index);
}
inline ::Ultima::MT4::Packets::HistoryOrderInfoDTO* OrdersHistoryDTO::mutable_orders(int index) {
  return orders_.Mutable(index);
}
inline ::Ultima::MT4::Packets::HistoryOrderInfoDTO* OrdersHistoryDTO::add_orders() {
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::HistoryOrderInfoDTO >&
OrdersHistoryDTO::orders() const {
  return orders_;
}
inline ::google::protobuf::RepeatedPtrField< ::Ultima::MT4::Packets::HistoryOrderInfoDTO >*
OrdersHistoryDTO::mutable_orders() {
  return &orders_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Packets
}  // namespace MT4
}  // namespace Ultima

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protocol_2eproto__INCLUDED
